
import { BacktestData, Trade, StrategyMetrics, TechnicalIndicators } from '@/types/trading';
import { calculateIndicators } from '@/utils/technicalIndicators';

// ===== ุงุณุชุฑุงุชูุฌูุฉ ุฑูู 1: Grid Strategy =====
export const GRID_STRATEGY_PARAMETERS = {
  // ูุนุงููุงุช ุฑุฃุณ ุงููุงู ูุฅุฏุงุฑุฉ ุงููุฎุงุทุฑ
  INITIAL_CAPITAL: 10000,
  LEVERAGE: 2,
  LIQUIDATION_PRICE: 30000,
  GRID_COUNT: 8,
  SAFE_CAPITAL_RATIO: 0.8,
  POSITION_CAPITAL_RATIO: 0.9,

  // ูุนุงููุงุช ุงููุคุดุฑุงุช ุงูุชูููุฉ โ (ุชู ุงูุชุนุฏูู ุญุณุจ ูุชุงุฆุฌ Optuna)
  SMA_SHORT_PERIOD: 15,
  SMA_LONG_PERIOD: 43,
  RSI_PERIOD: 23,
  BOLLINGER_PERIOD: 10,
  BOLLINGER_STD_DEV: 2.4,
  EMA_FAST: 14,
  EMA_SLOW: 26,
  MACD_SIGNAL: 14,

  // ูุนุงููุงุช ุฅุดุงุฑุงุช ุงูุดุฑุงุก
  BUY_SIGNALS: {
    RSI_OVERSOLD_STRONG: 35,
    RSI_OVERSOLD_WEAK: 45,
    BOLLINGER_LOWER_BUFFER: 1.02, // 2% ููู ุงูุฎุท ุงูุณููู
    PRICE_DROP_THRESHOLD_1: 3, // 3%
    PRICE_DROP_THRESHOLD_2: 5, // 5%
    VOLUME_MULTIPLIER: 1.5, // 1.5x ูู ุงููุชูุณุท
    VOLUME_PERIOD: 10,
    MIN_BUY_SCORE: 4, // ุงูุญุฏ ุงูุฃุฏูู ูููุงุท ุงูุดุฑุงุก
  },

  // ูุนุงููุงุช ุฅุดุงุฑุงุช ุงูุจูุน
  SELL_SIGNALS: {
    RSI_OVERBOUGHT_STRONG: 70,
    RSI_OVERBOUGHT_MEDIUM: 60,
    BOLLINGER_UPPER_BUFFER: 0.98, // 98% ูู ุงูุฎุท ุงูุนููู
    VOLUME_DROP_THRESHOLD: 0.7, // ุงูุฎูุงุถ ุงูุญุฌู ุฅูู 70%
    CANDLE_BODY_THRESHOLD: 0.7, // 70% ูู ูุทุงู ุงูุดูุนุฉ
    DECLINING_CANDLES_THRESHOLD: 3, // 3 ุดููุน ูุชุชุงููุฉ ูุงุจุทุฉ
    PRICE_HIGH_POSITION: 0.95, // 95% ูู ุฃุนูู ุณุนุฑ
    RSI_HIGH_POSITION: 0.9, // 90% ูู ุฃุนูู RSI
    MIN_SELL_SCORE: 4, // ุงูุญุฏ ุงูุฃุฏูู ูููุงุท ุงูุจูุน
    LOOKBACK_PERIOD: 10, // ูุชุฑุฉ ุงููุธุฑ ููุฎูู ููุชุญููู
  },

  // ูุนุงููุงุช ุงูุชุญููู ุงูุนุงู
  MIN_DATA_POINTS: 50, // ุงูุญุฏ ุงูุฃุฏูู ูููุงุท ุงูุจูุงูุงุช ููุชุญููู
  TREND_ANALYSIS_PERIOD: 9, // ูุชุฑุฉ ุชุญููู ุงูุงุชุฌุงู
};

// Risk Management System with Grid Strategy
class RiskManager {
  private initialCapital: number;
  private leverage: number;
  private liquidationPrice: number;
  private gridCount: number;
  private maxPositionPerGrid: number;
  
  constructor(initialCapital: number) {
    this.initialCapital = initialCapital;
    this.leverage = GRID_STRATEGY_PARAMETERS.LEVERAGE;
    this.liquidationPrice = GRID_STRATEGY_PARAMETERS.LIQUIDATION_PRICE;
    this.gridCount = GRID_STRATEGY_PARAMETERS.GRID_COUNT;
    this.maxPositionPerGrid = this.calculateMaxPositionPerGrid();
  }
  
  private calculateMaxPositionPerGrid(): number {
    const safeEntryPrice = this.liquidationPrice * 2;
    const safeCapital = this.initialCapital * GRID_STRATEGY_PARAMETERS.SAFE_CAPITAL_RATIO;
    return safeCapital / this.gridCount;
  }
  
  getPositionSize(currentPrice: number, availableCapital: number): number {
    const maxAllowed = Math.min(this.maxPositionPerGrid, availableCapital * GRID_STRATEGY_PARAMETERS.POSITION_CAPITAL_RATIO);
    return (maxAllowed * this.leverage) / currentPrice;
  }
  
  shouldTakeProfit(currentPrice: number, buyPrice: number): boolean {
    return currentPrice > buyPrice;
  }
}

// Market Trend Analysis
const analyzeMarketTrend = (data: BacktestData[], indicators: TechnicalIndicators, index: number): 'bullish' | 'bearish' => {
  if (index < GRID_STRATEGY_PARAMETERS.SMA_LONG_PERIOD) return 'bullish';
  
  const currentSMA20 = indicators.sma20[index];
  const currentSMA50 = indicators.sma50[index];
  const currentRSI = indicators.rsi[index];
  const macdLine = indicators.macd.macd[index];
  const macdSignal = indicators.macd.signal[index];
  
  let bullishSignals = 0;
  let bearishSignals = 0;
  
  if (currentSMA20 > currentSMA50) bullishSignals++;
  else bearishSignals++;
  
  if (currentRSI < 50) bearishSignals++;
  else if (currentRSI > 50) bullishSignals++;
  
  if (macdLine > macdSignal) bullishSignals++;
  else bearishSignals++;
  
  const recentPrices = data.slice(Math.max(0, index - GRID_STRATEGY_PARAMETERS.TREND_ANALYSIS_PERIOD), index + 1).map(d => d.close);
  const priceSlope = (recentPrices[recentPrices.length - 1] - recentPrices[0]) / recentPrices.length;
  
  if (priceSlope > 0) bullishSignals++;
  else bearishSignals++;
  
  return bullishSignals > bearishSignals ? 'bullish' : 'bearish';
};

// ุชุญููู ุฅุดุงุฑุงุช ูุจูุท ุงูุณูู
const detectMarketDownturn = (data: BacktestData[], indicators: TechnicalIndicators, index: number): { shouldSell: boolean; reason: string; confidence: number } => {
  if (index < GRID_STRATEGY_PARAMETERS.MIN_DATA_POINTS) return { shouldSell: false, reason: 'ุจูุงูุงุช ุบูุฑ ูุงููุฉ', confidence: 0 };
  
  const currentRSI = indicators.rsi[index];
  const currentSMA20 = indicators.sma20[index];
  const currentSMA50 = indicators.sma50[index];
  const prevSMA20 = indicators.sma20[index - 1];
  const prevSMA50 = indicators.sma50[index - 1];
  const macdLine = indicators.macd.macd[index];
  const macdSignal = indicators.macd.signal[index];
  const prevMACD = indicators.macd.macd[index - 1];
  const prevMACDSignal = indicators.macd.signal[index - 1];
  const bollingerUpper = indicators.bollinger.upper[index];
  const currentPrice = data[index].close;
  
  let sellScore = 0;
  let reasons: string[] = [];
  
  // 1. RSI ูู ููุทูุฉ ุฐุฑูุฉ ุงูุดุฑุงุก
  if (currentRSI > GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.RSI_OVERBOUGHT_STRONG) {
    sellScore += 3;
    reasons.push(`RSI ูู ุฐุฑูุฉ ุงูุดุฑุงุก (>${GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.RSI_OVERBOUGHT_STRONG})`);
  } else if (currentRSI > GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.RSI_OVERBOUGHT_MEDIUM) {
    sellScore += 1;
    reasons.push(`RSI ูุฑุชูุน (>${GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.RSI_OVERBOUGHT_MEDIUM})`);
  }
  
  // 2. ูุณุฑ ุงููุชูุณุท ุงููุชุญุฑู ููุฃุณูู
  if (currentSMA20 < currentSMA50 && prevSMA20 >= prevSMA50) {
    sellScore += 4;
    reasons.push('ูุณุฑ SMA20 ุชุญุช SMA50');
  }
  
  // 3. MACD ุณูุจู ุฃู ูุชุฌู ููุงูุฎูุงุถ
  if (macdLine < macdSignal && prevMACD >= prevMACDSignal) {
    sellScore += 3;
    reasons.push('MACD ูุณุฑ ุชุญุช ุฎุท ุงูุฅุดุงุฑุฉ');
  }
  
  // 4. ุงูุณุนุฑ ูุฑูุจ ูู ุฎุท ุจููููุฌุฑ ุงูุนููู (ุฐุฑูุฉ ุดุฑุงุก)
  if (currentPrice >= bollingerUpper * GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.BOLLINGER_UPPER_BUFFER) {
    sellScore += 2;
    reasons.push('ุงูุณุนุฑ ูุฑูุจ ูู ุฎุท ุจููููุฌุฑ ุงูุนููู');
  }
  
  // 5. ุงูุฎูุงุถ ุญุงุฏ ูู ุงูุญุฌู (ุถุนู ูู ุงูุฒุฎู)
  const avgVolume = data.slice(Math.max(0, index - GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.LOOKBACK_PERIOD), index).reduce((sum, d) => sum + d.volume, 0) / GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.LOOKBACK_PERIOD;
  if (data[index].volume < avgVolume * GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.VOLUME_DROP_THRESHOLD) {
    sellScore += 1;
    reasons.push('ุงูุฎูุงุถ ุญุฌู ุงูุชุฏุงูู');
  }
  
  // 6. ุชุญููู ุงูุดููุน - ุดูุนุฉ ูุงุจุทุฉ ูููุฉ
  const currentCandle = data[index];
  const bodySize = Math.abs(currentCandle.close - currentCandle.open);
  const candleRange = currentCandle.high - currentCandle.low;
  const bodyPercentage = bodySize / candleRange;
  
  if (currentCandle.close < currentCandle.open && bodyPercentage > GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.CANDLE_BODY_THRESHOLD) {
    sellScore += 2;
    reasons.push('ุดูุนุฉ ูุงุจุทุฉ ูููุฉ');
  }
  
  // 7. ููุท ูุจูุท ูุชุชุงูู ูู ุงูุฃุณุนุงุฑ
  const last5Prices = data.slice(index - 4, index + 1).map(d => d.close);
  const decliningCount = last5Prices.reduce((count, price, i) => {
    if (i > 0 && price < last5Prices[i - 1]) count++;
    return count;
  }, 0);
  
  if (decliningCount >= GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.DECLINING_CANDLES_THRESHOLD) {
    sellScore += 2;
    reasons.push(`ุงูุฎูุงุถ ูุชุชุงูู ูู ${decliningCount} ูู ุขุฎุฑ 5 ุดููุน`);
  }
  
  // 8. RSI ูุดูู divergence ูุงุจุท
  const priceHigh = Math.max(...data.slice(index - GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.LOOKBACK_PERIOD, index + 1).map(d => d.high));
  const rsiHigh = Math.max(...indicators.rsi.slice(index - GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.LOOKBACK_PERIOD, index + 1).filter(r => !isNaN(r)));
  const currentPricePosition = currentPrice / priceHigh;
  const currentRSIPosition = currentRSI / rsiHigh;
  
  if (currentPricePosition > GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.PRICE_HIGH_POSITION && currentRSIPosition < GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.RSI_HIGH_POSITION) {
    sellScore += 2;
    reasons.push('ุชุจุงุนุฏ ูุงุจุท ุจูู ุงูุณุนุฑ ู RSI');
  }
  
  // ุญุณุงุจ ูุณุชูู ุงูุซูุฉ
  const confidence = Math.min(sellScore * 10, 100);
  
  // ูุฑุงุฑ ุงูุจูุน: ูุญุชุงุฌ ููุงุท ูุงููุฉ
  const shouldSell = sellScore >= GRID_STRATEGY_PARAMETERS.SELL_SIGNALS.MIN_SELL_SCORE;
  const reason = reasons.length > 0 ? reasons.join(' | ') : 'ูุง ุชูุฌุฏ ุฅุดุงุฑุงุช ุจูุน ูููุฉ';
  
  if (shouldSell) {
    console.log(`๐ด ุฅุดุงุฑุฉ ุจูุน ูููุฉ - ุงูููุงุท: ${sellScore}, ุงูุฃุณุจุงุจ: ${reason}, ุงูุซูุฉ: ${confidence}%`);
  }
  
  return { shouldSell, reason, confidence };
};

// Advanced Trading Strategy with Grid System
const generateSignals = (data: BacktestData[], indicators: TechnicalIndicators): ('buy' | 'sell' | 'hold')[] => {
  const signals: ('buy' | 'sell' | 'hold')[] = [];
  
  for (let i = 0; i < data.length; i++) {
    let signal: 'buy' | 'sell' | 'hold' = 'hold';
    
    if (i < GRID_STRATEGY_PARAMETERS.MIN_DATA_POINTS) {
      signals.push(signal);
      continue;
    }
    
    const currentRSI = indicators.rsi[i];
    const currentSMA20 = indicators.sma20[i];
    const currentSMA50 = indicators.sma50[i];
    const currentPrice = data[i].close;
    const prevSMA20 = indicators.sma20[i - 1];
    const prevSMA50 = indicators.sma50[i - 1];
    const macdLine = indicators.macd.macd[i];
    const macdSignal = indicators.macd.signal[i];
    const bollingerLower = indicators.bollinger.lower[i];
    
    // ูุญุต ุฅุดุงุฑุงุช ุงูุจูุน ุฃููุงู
    const sellAnalysis = detectMarketDownturn(data, indicators, i);
    if (sellAnalysis.shouldSell) {
      signal = 'sell';
      signals.push(signal);
      continue;
    }
    
    // ุฅุดุงุฑุงุช ุงูุดุฑุงุก
    let buyScore = 0;
    
    if (currentRSI < GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.RSI_OVERSOLD_STRONG) buyScore += 2;
    else if (currentRSI < GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.RSI_OVERSOLD_WEAK) buyScore += 1;
    
    if (currentSMA20 > currentSMA50 && prevSMA20 <= prevSMA50) buyScore += 3;
    
    if (macdLine > macdSignal && indicators.macd.macd[i-1] <= indicators.macd.signal[i-1]) buyScore += 2;
    
    if (currentPrice <= bollingerLower * GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.BOLLINGER_LOWER_BUFFER) buyScore += 2;
    
    const priceDropPercent = ((data[i-5]?.close || currentPrice) - currentPrice) / (data[i-5]?.close || currentPrice) * 100;
    if (priceDropPercent > GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.PRICE_DROP_THRESHOLD_1) buyScore += 1;
    if (priceDropPercent > GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.PRICE_DROP_THRESHOLD_2) buyScore += 2;
    
    const avgVolume = data.slice(Math.max(0, i-GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.VOLUME_PERIOD), i).reduce((sum, d) => sum + d.volume, 0) / GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.VOLUME_PERIOD;
    if (data[i].volume > avgVolume * GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.VOLUME_MULTIPLIER) buyScore += 1;
    
    if (buyScore >= GRID_STRATEGY_PARAMETERS.BUY_SIGNALS.MIN_BUY_SCORE) {
      signal = 'buy';
    }
    
    signals.push(signal);
  }
  
  return signals;
};

// Position Management
interface Position {
  id: string;
  entryPrice: number;
  quantity: number;
  entryTime: string;
  gridLevel: number;
}

// Run Enhanced Backtest with Risk Management (Strategy 1)
export const runGridStrategy = (data: BacktestData[]): StrategyMetrics => {
  console.log('Starting Strategy 1: Enhanced Grid Strategy...');
  
  const initialCapital = GRID_STRATEGY_PARAMETERS.INITIAL_CAPITAL;
  const riskManager = new RiskManager(initialCapital);
  const leverage = GRID_STRATEGY_PARAMETERS.LEVERAGE;
  
  let capital = initialCapital;
  const positions: Position[] = [];
  const trades: Trade[] = [];
  const equityCurve: { timestamp: string; equity: number; drawdown: number }[] = [];
  
  let gridLevel = 0;
  let maxEquity = initialCapital;
  
  const indicators = calculateIndicators(data);
  const signals = generateSignals(data, indicators);
  
  for (let i = 1; i < data.length; i++) {
    const currentData = data[i];
    const signal = signals[i];
    const price = currentData.close;
    
    // ุญุณุงุจ ูููุฉ ุงููุญูุธุฉ ุงูุญุงููุฉ ุจุดูู ุตุญูุญ
    const positionsValue = positions.reduce((sum, pos) => {
      const priceChange = price - pos.entryPrice;
      const pnlPerUnit = priceChange * leverage;
      const totalPnl = pnlPerUnit * pos.quantity;
      const entryValue = (pos.quantity * pos.entryPrice) / leverage;
      return sum + entryValue + totalPnl;
    }, 0);
    
    const currentEquity = capital + positionsValue;
    
    maxEquity = Math.max(maxEquity, currentEquity);
    const drawdown = (maxEquity - currentEquity) / maxEquity * 100;
    
    equityCurve.push({
      timestamp: currentData.timestamp,
      equity: currentEquity,
      drawdown: drawdown
    });
    
    // ุฅุดุงุฑุฉ ุดุฑุงุก - ุงุณุชุฎุฏุงู ูุธุงู ุงูุดุจูุฉ
    if (signal === 'buy' && capital > 100 && gridLevel < GRID_STRATEGY_PARAMETERS.GRID_COUNT) {
      const positionSize = riskManager.getPositionSize(price, capital);
      const requiredCapital = (positionSize * price) / leverage;
      
      if (capital >= requiredCapital) {
        const position: Position = {
          id: `pos_${i}_${gridLevel}`,
          entryPrice: price,
          quantity: positionSize,
          entryTime: currentData.timestamp,
          gridLevel: gridLevel
        };
        
        positions.push(position);
        capital -= requiredCapital;
        gridLevel++;
        
        trades.push({
          timestamp: currentData.timestamp,
          type: 'buy',
          price: price,
          quantity: positionSize
        });
        
        console.log(`๐ข ุดุฑุงุก ูู ุงูุดุจูุฉ ${gridLevel}: ุงูุณุนุฑ ${price.toFixed(2)}, ุงููููุฉ: ${positionSize.toFixed(6)}`);
      }
    }
    
    // ูุญุต ุงููุฑุงูุฒ ููุจูุน - ุงูุชุญููู ุงูููู ููุท ูุน ุดุฑุท ุงูุฑุจุญ
    const positionsToClose: number[] = [];
    const sellAnalysis = detectMarketDownturn(data, indicators, i);
    
    positions.forEach((position, index) => {
      const priceChange = price - position.entryPrice;
      const pnlPerUnit = priceChange * leverage;
      const totalPnl = pnlPerUnit * position.quantity;
      
      // ุดุฑุท ุฃุณุงุณู: ูุฌุจ ุฃู ูููู ููุงู ุฑุจุญ
      const isProfit = totalPnl > 0;
      
      // ุฅุดุงุฑุฉ ุงูุจูุน ูู ุงูุชุญููู ุงูููู
      const hasAnalyticalSellSignal = sellAnalysis.shouldSell;
      
      // ุงูุจูุน ููุท ุนูุฏ ุงูุฑุจุญ + ูุฌูุฏ ุฅุดุงุฑุฉ ุจูุน ุชุญููููุฉ
      if (isProfit && hasAnalyticalSellSignal) {
        const entryValue = (position.quantity * position.entryPrice) / leverage;
        const exitValue = entryValue + totalPnl;
        
        capital += exitValue;
        positionsToClose.push(index);
        
        trades.push({
          timestamp: currentData.timestamp,
          type: 'sell',
          price: price,
          quantity: position.quantity,
          pnl: totalPnl
        });
        
        console.log(`๐ฐ ุจูุน ูุฑุจุญ ุจุฅุดุงุฑุฉ ุชุญููููุฉ: ุงูุฏุฎูู ${position.entryPrice.toFixed(2)}, ุงูุฎุฑูุฌ ${price.toFixed(2)}, P&L: ${totalPnl.toFixed(2)}, ุงูุณุจุจ: ${sellAnalysis.reason}`);
      } else if (isProfit && !hasAnalyticalSellSignal) {
        console.log(`๐ ุฑุจุญ ูููู ูุง ุชูุฌุฏ ุฅุดุงุฑุฉ ุจูุน ุชุญููููุฉ: P&L: ${totalPnl.toFixed(2)}, ุงูุชุธุงุฑ ุฅุดุงุฑุฉ`);
      } else if (!isProfit) {
        console.log(`โณ ุงูุงุญุชูุงุธ ุจุงููุฑูุฒ ุงูุฎุงุณุฑ: ุงูุฏุฎูู ${position.entryPrice.toFixed(2)}, ุงูุณุนุฑ ุงูุญุงูู ${price.toFixed(2)}, P&L: ${totalPnl.toFixed(2)}`);
      }
    });
    
    // ุฅุฒุงูุฉ ุงููุฑุงูุฒ ุงููุบููุฉ
    positionsToClose.reverse().forEach(index => {
      positions.splice(index, 1);
      gridLevel = Math.max(0, gridLevel - 1);
    });
  }
  
  // ุฅุบูุงู ุงููุฑุงูุฒ ุงููุชุจููุฉ ููุท ุฅุฐุง ูุงูุช ูุฑุจุญุฉ ูู ููุงูุฉ ูุชุฑุฉ ุงูุงุฎุชุจุงุฑ
  if (positions.length > 0 && data.length > 0) {
    const lastPrice = data[data.length - 1].close;
    const positionsToClose: number[] = [];
    
    positions.forEach((position, index) => {
      const priceChange = lastPrice - position.entryPrice;
      const pnlPerUnit = priceChange * leverage;
      const totalPnl = pnlPerUnit * position.quantity;
      
      // ุฅุบูุงู ููุท ุงููุฑุงูุฒ ุงููุฑุจุญุฉ ูู ููุงูุฉ ุงูุงุฎุชุจุงุฑ
      if (totalPnl > 0) {
        const entryValue = (position.quantity * position.entryPrice) / leverage;
        const exitValue = entryValue + totalPnl;
        
        capital += exitValue;
        positionsToClose.push(index);
        
        trades.push({
          timestamp: data[data.length - 1].timestamp,
          type: 'sell',
          price: lastPrice,
          quantity: position.quantity,
          pnl: totalPnl
        });
        
        console.log(`๐ ุฅุบูุงู ูุฑุจุญ ูู ููุงูุฉ ุงูุงุฎุชุจุงุฑ: P&L ${totalPnl.toFixed(2)}`);
      } else {
        console.log(`๐ ุชุฑู ูุฑูุฒ ุฎุงุณุฑ ููุชูุญ: P&L ${totalPnl.toFixed(2)}`);
      }
    });
    
    // ุฅุฒุงูุฉ ุงููุฑุงูุฒ ุงููุบููุฉ
    positionsToClose.reverse().forEach(index => {
      positions.splice(index, 1);
    });
  }
  
  // ุญุณุงุจ ุฑุฃุณ ุงููุงู ุงูููุงุฆู ูุน ุงููุฑุงูุฒ ุงูููุชูุญุฉ
  let finalCapital = capital;
  if (positions.length > 0 && data.length > 0) {
    const lastPrice = data[data.length - 1].close;
    const openPositionsValue = positions.reduce((sum, pos) => {
      const priceChange = lastPrice - pos.entryPrice;
      const pnlPerUnit = priceChange * leverage;
      const totalPnl = pnlPerUnit * pos.quantity;
      const entryValue = (pos.quantity * pos.entryPrice) / leverage;
      return sum + entryValue + totalPnl;
    }, 0);
    finalCapital += openPositionsValue;
    
    console.log(`๐ ุงููุฑุงูุฒ ุงูููุชูุญุฉ ุงููุชุจููุฉ: ${positions.length}, ูููุชูุง: ${openPositionsValue.toFixed(2)}`);
  }
  
  // ุญุณุงุจ ุงูููุงููุณ
  const totalReturn = ((finalCapital - initialCapital) / initialCapital) * 100;
  
  const firstDate = new Date(data[0].timestamp);
  const lastDate = new Date(data[data.length - 1].timestamp);
  const yearsElapsed = (lastDate.getTime() - firstDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000);
  const annualizedReturn = (Math.pow(finalCapital / initialCapital, 1 / yearsElapsed) - 1) * 100;
  
  const profitableTrades = trades.filter(trade => trade.pnl && trade.pnl > 0);
  const losingTrades = trades.filter(trade => trade.pnl && trade.pnl < 0);
  const sellTrades = trades.filter(trade => trade.type === 'sell');
  
  const winRate = sellTrades.length > 0 ? (profitableTrades.length / sellTrades.length) * 100 : 0;
  const averageWin = profitableTrades.length > 0 ? 
    profitableTrades.reduce((sum, trade) => sum + (trade.pnl || 0), 0) / profitableTrades.length : 0;
  const averageLoss = losingTrades.length > 0 ? 
    Math.abs(losingTrades.reduce((sum, trade) => sum + (trade.pnl || 0), 0) / losingTrades.length) : 0;
  
  const totalProfit = profitableTrades.reduce((sum, trade) => sum + (trade.pnl || 0), 0);
  const totalLoss = Math.abs(losingTrades.reduce((sum, trade) => sum + (trade.pnl || 0), 0));
  const profitFactor = totalLoss > 0 ? totalProfit / totalLoss : totalProfit > 0 ? Infinity : 0;
  
  const maxDrawdown = Math.max(...equityCurve.map(point => point.drawdown));
  
  const returns = equityCurve.map((point, i) => 
    i > 0 ? (point.equity - equityCurve[i-1].equity) / equityCurve[i-1].equity : 0
  ).slice(1);
  
  const averageReturn = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
  const returnStdDev = Math.sqrt(
    returns.reduce((sum, ret) => sum + Math.pow(ret - averageReturn, 2), 0) / returns.length
  );
  const sharpeRatio = returnStdDev > 0 ? (averageReturn / returnStdDev) * Math.sqrt(252) : 0;
  
  console.log('Strategy 1: Enhanced Grid Strategy completed:', {
    totalTrades: trades.length,
    totalReturn,
    winRate,
    finalCapital,
    openPositions: positions.length,
    strategy: 'Grid System - Profit Only Selling'
  });
  
  return {
    totalReturn,
    annualizedReturn,
    sharpeRatio,
    maxDrawdown,
    winRate,
    totalTrades: trades.length,
    winningTrades: profitableTrades.length,
    losingTrades: losingTrades.length,
    averageWin,
    averageLoss,
    profitFactor,
    initialCapital,
    finalCapital,
    trades,
    equityCurve
  };
};
